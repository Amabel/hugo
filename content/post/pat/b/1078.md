---
author: "Weibin Luo"
title: "PAT 1078. 字符串压缩与解压 (20)"
date: 2018-05-09T00:00:03+09:00
draft: false
tags:
- algorithm
- pat
categories:
- pat
keywords:
- pat
thumbnailImage:
thumbnailImagePosition: bottom
---
文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。

解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。

本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。
<!--more-->
输入格式：

输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过1000个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过1MB。

输出格式：

根据要求压缩或解压字符串，并在一行中输出结果。

**输入样例1：**
```
C
TTTTThhiiiis isssss a   tesssst CAaaa as
```
**输出样例1：**
```
5T2h4is i5s a3 te4st CA3a as
```
**输入样例2：**
```
D
5T2h4is i5s a3 te4st CA3a as10Z
```
**输出样例2：**
```
TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ
```

---

# 分析

解压时要注意重复次数可能超过 10，所以要先连续读入数字之后一并转化成整数。

另外由于输入存在空格所以不能用`cin`而要改用`getline(cin, s)`来读取一整行。

# 代码

{{< tabbed-codeblock "pat 1078. 字符串压缩与解压" >}}
<!-- tab cpp -->
#include <iostream>
using namespace std;
void enc(string s) {
    for (int i = 0; i < s.length(); i++) {
        int count = 1;
        char c = s[i];
        while (c == s[i + 1]) {
            count++;
            i ++;
        }
        if (count > 1) {
            cout << count << c;
        } else if (count == 1) {
            cout << c;
        }
    }
}
void dec(string s) {
    string n = "";
    for (int i = 0; i < s.length(); i++) {
        if ('0' <= s[i] && s[i] <= '9') {
            n += s[i];
        } else {
            int count = 1;
            if (n != "") {
                count = stoi(n);
            }
            for (int j = 0; j < count; j++) {
                cout << s[i];
            }
            n = "";
        }
    }
}
int main() {
    char c;
    string s;
    cin >> c;
    getchar();
    getline(cin, s);
    if (c == 'C') {
        enc(s);
    } else if (c == 'D') {
        dec(s);
    }
    return 0;
}
<!-- endtab -->
{{< /tabbed-codeblock >}}
